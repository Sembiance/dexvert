import {xu} from "xu";
import {fileUtil} from "xutil";
import {path, assertStrictEquals} from "std";
import {Format} from "../../src/Format.js";
import {families} from "../../src/family/families.js";

export default async function buildFormats(xlog)
{
	const formatDirPath = path.join(xu.dirname(import.meta), "..", "..", "src", "format");
	xlog.info`Finding format JS files...`;
	const formatFilePaths = await fileUtil.tree(formatDirPath, {nodir : true, regex : /[^/]+\/.+\.js$/});
	xlog.info`Processing ${formatFilePaths.length} format files...`;

	const relPaths = [];
	const formats = {};
	const existingFormatids = new Set();

	for(const formatFilePath of formatFilePaths)
	{
		if(formatFilePath.endsWith("formats.js"))
			continue;

		const formatModule = await import(formatFilePath);
		const formatid = Object.keys(formatModule).find(k => k.at(0)!=="_");
		const familyid = path.basename(path.dirname(formatFilePath));
		if(!families[familyid])
			throw new Error(`format [${formatid}] at [${formatFilePath}] is in a directory [${familyid}] that does not have a family class`);

		// class name must match filename
		assertStrictEquals(formatid, path.basename(formatFilePath, ".js"), `format file [${formatFilePath}] does not have a matching class name [${formatid}]`);

		// check for duplicates
		if(existingFormatids.has(formatid.toLowerCase()))
			throw new Error(`format [${formatid}] at [${formatFilePath}] is a duplicate`);

		// create the class and validate it
		const format = formatModule[formatid].create(families[familyid]);
		if(!(format instanceof Format))
			throw new Error(`format [${formatid}] at [${formatFilePath}] is not of type Format`);

		// some manual checks on meta providers based on what converters are being used
		for(const [converter, metaProvider] of Object.entries({"convert" : "image", "darktable_cli" : "darkTable", "ansilove" : "ansiArt"}))
		{
			const allowFormatsMetaMismatch = ["ttf", "otf", "pcd"];
			if(Array.isArray(format.converters) && format.converters.some(v => v===converter || (typeof v==="string" && v.startsWith(`${converter}[`))) && !(format.metaProvider || []).includes(metaProvider) && !allowFormatsMetaMismatch.includes(formatid))
				throw new Error(`format ${formatid} has ${converter} as a converter, but NOT ${metaProvider} as a metaProvider.`);
		}

		if(Object.hasOwn(format, "forbidExtMatch") && !Object.hasOwn(format, "ext"))
			xlog.error`format ${formatid} has forbidExtMatch, but no ext`;

		formats[formatid] = format;
		existingFormatids.add(formatid.toLowerCase());
		relPaths.push([familyid, formatid, path.relative(formatDirPath, formatFilePath)]);
	}

	xlog.info`Writing formats.js`;
	await fileUtil.writeTextFile(path.join(formatDirPath, "formats.js"), `/* eslint-disable eslint-comments/no-unlimited-disable */
/* eslint-disable */
// DO NOT EDIT MANUALLY
// AUTO GENERATED BY build/buildFormats.js
// DO NOT EDIT MANUALLY
import {xu} from "xu";
import {families} from "../family/families.js";
import {Format} from "../Format.js";
const formats = {};
${relPaths.map(([familyid, formatid, relPath]) => `import {${formatid}} from "./${relPath}";\nformats.${formatid} = ${formatid}.create(families.${familyid});`).join("\n")}

// process our 'unsupported.js' formats
const {default : unsupported} = await import("./unsupported.js");
for(const [familyid, unsupportedFormats] of Object.entries(unsupported))
{
	for(const [formatid, o] of Object.entries(unsupportedFormats))
	{
		if(formats[formatid])
			throw new Error(\`format [\${formatid}] in unsupported.js is a duplicate of \${formats[formatid]}\`);

		const supportedKeys = ["ext", "filename", "forbiddenMagic", "magic", "name", "notes", "weakFilename", "weakMagic", "website"];
		const extraKeys = Object.keys(o).subtractAll(supportedKeys);
		if(extraKeys.length>0)
			throw new Error(\`unsupported format \${familyid}/\${formatid} has extra keys that are not currently copied over to the Unknown class, add them: \${extraKeys}\`);
		
		class Unsupported extends Format
		{
			unsupported = true;
		}

		formats[formatid] = Unsupported.create(families[familyid], format =>
		{
			for(const supportedKey of supportedKeys)
			{
				if(Object.hasOwn(o, supportedKey))
					format[supportedKey] = o[supportedKey];
			}
		});
		formats[formatid].formatid = formatid;
	}
}

// process our 'simple.js' formats
const {default : simple} = await import("./simple.js");
for(const [familyid, simpleFormats] of Object.entries(simple))
{
	for(const [formatid, o] of Object.entries(simpleFormats))
	{
		if(formats[formatid])
			throw new Error(\`format [\${formatid}] in simple.js is a duplicate\`);

		const supportedKeys = ["ext", "filename", "forbiddenMagic", "magic", "name", "trustMagic", "weakMagic", "website"];
		const extraKeys = Object.keys(o).subtractAll(supportedKeys);
		if(extraKeys.length>0)
			throw new Error(\`simple format \${familyid}/\${formatid} has extra keys that are not currently copied over to the Simple class, add them: \${extraKeys}\`);
		
		class Simple extends Format
		{
			converters = ["strings"];
			packed     = true;
		}

		formats[formatid] = Simple.create(families[familyid], format =>
		{
			for(const supportedKey of supportedKeys)
			{
				if(Object.hasOwn(o, supportedKey))
					format[supportedKey] = o[supportedKey];
			}
			if(o.ext?.length)
				format.forbidExtMatch = true;
		});
		formats[formatid].formatid = formatid;
	}
}

export {formats};
`);
}
