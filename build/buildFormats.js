import {xu} from "xu";
import {fileUtil, cmdUtil} from "xutil";
import {path, assertStrictEquals} from "std";
import {Format} from "../src/Format.js";
import {families} from "../src/family/families.js";

if(!cmdUtil.cmdInit({opts : { silent : {desc : "Don't output any messages"}}}).silent)
	xu.verbose = 3;

const formatDirPath = path.join(xu.dirname(import.meta), "..", "src", "format");
xu.log1`Finding format JS files...`;
const formatFilePaths = await fileUtil.tree(formatDirPath, {nodir : true, regex : /[^/]+\/.+\.js$/});
xu.log1`Processing ${formatFilePaths.length} format files...`;

const relPaths = [];
const formats = {};

for(const formatFilePath of formatFilePaths)
{
	if(formatFilePath.endsWith("formats.js"))
		continue;

	// TODO REMOVE BELOW AFTER CONVERTING ALL FORMATS
	if(!(await fileUtil.readFile(formatFilePath)).includes(" extends Format") || (await fileUtil.readFile(formatFilePath)).startsWith("/*"))
		continue;
	// TODO REMOVE ABOVE AFTER CONVERTING ALL FORMATS

	const formatModule = await import(formatFilePath);
	const formatid = Object.keys(formatModule)[0];
	const familyid = path.basename(path.dirname(formatFilePath));
	if(!families[familyid])
		throw new Error(`format [${formatid}] at [${formatFilePath}] is in a directory [${familyid}] that does not have a family class`);

	// class name must match filename
	assertStrictEquals(formatid, path.basename(formatFilePath, ".js"), `format file [${formatFilePath}] does not have a matching class name [${formatid}]`);

	// check for duplicates
	if(formats[formatid])
		throw new Error(`format [${formatid}] at [${formatFilePath}] is a duplicate of ${formats[formatid]}`);

	// create the class and validate it
	const format = formatModule[formatid].create(families[familyid]);
	if(!(format instanceof Format))
		throw new Error(`format [${formatid}] at [${formatFilePath}] is not of type Format`);

	// some manual checks on meta providers based on what converters are being used
	for(const [converter, metaProvider] of Object.entries({"convert" : "image", "darktable_cli" : "darkTable", "ansilove" : "ansiArt"}))
	{
		if(Array.isArray(format.converters) && format.converters.some(v => v===converter || v.startsWith(`${converter}[`)) && !(format.metaProviders || []).includes(metaProvider))
			throw new Error(`format ${formatid} has ${converter} as a converter, but NOT ${metaProvider} as a metaProvider.`);
	}

	formats[formatid] = format;
	relPaths.push([familyid, formatid, path.relative(formatDirPath, formatFilePath)]);
}

xu.log1`Writing formats.js`;
await fileUtil.writeFile(path.join(formatDirPath, "formats.js"), `
// DO NOT EDIT MANUALLY
// AUTO GENERATED BY build/buildFormats.js
// DO NOT EDIT MANUALLY
import {families} from "../family/families.js";
import unsupported from "./unsupported.js";
import {Format} from "../Format.js";
const formats = {};
${relPaths.map(([familyid, formatid, relPath]) => `import {${formatid}} from "./${relPath}";\nformats.${formatid} = ${formatid}.create(families.${familyid});`).join("\n")}

// process our 'unsupported.js' formats
for(const [familyid, unsupportedFormats] of Object.entries(unsupported))
{
	for(const [formatid, o] of Object.entries(unsupportedFormats))
	{
		const supportedKeys = ["name", "ext", "magic", "weakMagic", "filename", "notes"];
		const extraKeys = Object.keys(o).subtractAll(supportedKeys);
		if(extraKeys.length>0)
			throw new Error(\`unsupported format \${familyid}/\${formatid} has extra keys that are not currently copied over to the Unknown class, add them: \${extraKeys}\`);
		
		class Unsupported extends Format
		{
			unsupported = true;
		}

		formats[formatid] = Unsupported.create(families[familyid], format =>	// eslint-disable-line sembiance/shorter-arrow-funs
		{
			for(const supportedKey of supportedKeys)
			{
				if(Object.hasOwn(o, supportedKey))
					format[supportedKey] = o[supportedKey];
			}
		});
	}
}
export {formats};
`);
