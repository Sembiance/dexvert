import {xu} from "xu";
import {fileUtil} from "xutil";
import {path, assertStrictEquals} from "std";
import {Format} from "../../src/Format.js";
import {families} from "../../src/family/families.js";

export default async function buildFormats(xlog)
{
	const formatDirPath = path.join(xu.dirname(import.meta), "..", "..", "src", "format");
	xlog.info`Finding format JS files...`;
	const formatFilePaths = await fileUtil.tree(formatDirPath, {nodir : true, regex : /[^/]+\/.+\.js$/});
	xlog.info`Processing ${formatFilePaths.length} format files...`;

	const relPaths = [];
	const formats = {};

	for(const formatFilePath of formatFilePaths)
	{
		if(formatFilePath.endsWith("formats.js"))
			continue;

		const formatModule = await import(formatFilePath);
		const formatid = Object.keys(formatModule).find(k => k.at(0)!=="_");
		const familyid = path.basename(path.dirname(formatFilePath));
		if(!families[familyid])
			throw new Error(`format [${formatid}] at [${formatFilePath}] is in a directory [${familyid}] that does not have a family class`);

		// class name must match filename
		assertStrictEquals(formatid, path.basename(formatFilePath, ".js"), `format file [${formatFilePath}] does not have a matching class name [${formatid}]`);

		// check for duplicates
		if(formats[formatid])
			throw new Error(`format [${formatid}] at [${formatFilePath}] is a duplicate of ${formats[formatid]}`);

		// create the class and validate it
		const format = formatModule[formatid].create(families[familyid]);
		if(!(format instanceof Format))
			throw new Error(`format [${formatid}] at [${formatFilePath}] is not of type Format`);

		// some manual checks on meta providers based on what converters are being used
		for(const [converter, metaProvider] of Object.entries({"convert" : "image", "darktable_cli" : "darkTable", "ansilove" : "ansiArt"}))
		{
			if(Array.isArray(format.converters) && format.converters.some(v => v===converter || (typeof v==="string" && v.startsWith(`${converter}[`))) && !(format.metaProvider || []).includes(metaProvider))
				throw new Error(`format ${formatid} has ${converter} as a converter, but NOT ${metaProvider} as a metaProvider.`);
		}

		formats[formatid] = format;
		relPaths.push([familyid, formatid, path.relative(formatDirPath, formatFilePath)]);
	}

	xlog.info`Writing formats.js`;
	await Deno.writeTextFile(path.join(formatDirPath, "formats.js"), `/* eslint-disable eslint-comments/no-unlimited-disable */
/* eslint-disable */
// DO NOT EDIT MANUALLY
// AUTO GENERATED BY build/buildFormats.js
// DO NOT EDIT MANUALLY
import {xu} from "xu";
import {families} from "../family/families.js";
import {Format} from "../Format.js";
const formats = {};
${relPaths.map(([familyid, formatid, relPath]) => `import {${formatid}} from "./${relPath}?v=${xu.randStr()}";\nformats.${formatid} = ${formatid}.create(families.${familyid});`).join("\n")}

// process our 'unsupported.js' formats
const {default : unsupported} = await import(\`./unsupported.js?v=$\{xu.randStr()}\`);
for(const [familyid, unsupportedFormats] of Object.entries(unsupported))
{
	for(const [formatid, o] of Object.entries(unsupportedFormats))
	{
		const supportedKeys = ["name", "ext", "magic", "weakMagic", "filename", "notes", "website", "weakFilename"];
		const extraKeys = Object.keys(o).subtractAll(supportedKeys);
		if(extraKeys.length>0)
			throw new Error(\`unsupported format \${familyid}/\${formatid} has extra keys that are not currently copied over to the Unknown class, add them: \${extraKeys}\`);
		
		class Unsupported extends Format
		{
			unsupported = true;
		}

		formats[formatid] = Unsupported.create(families[familyid], format =>
		{
			for(const supportedKey of supportedKeys)
			{
				if(Object.hasOwn(o, supportedKey))
					format[supportedKey] = o[supportedKey];
			}
		});
		formats[formatid].formatid = formatid;
	}
}

export async function reload()
{
	const {formats : newFormats} = await import(\`./formats.js?v=$\{xu.randStr()}\`);
	Object.clear(formats);
	Object.assign(formats, newFormats);
}

export {formats};
`);
}
